(do (setv matches (list-comp (zipmap [:cmd :nrs] (.groups it))
                              [it (finditer "([MmCcSsLl])([^A-DF-Za-df-z]+)" str)]))
    (loop [[points []]
           [i 0]]
          (if (< i (len commands))
            (let [[nr-str (-> (get matches :nrs) (.replace  "-" " -")
                              (.replace  "e -" "e-") (.strip))]
                  [numbers (map float (remove empty? (split " |," nr-str)))]
                  [pts (partition 2 2 numbers)]
                  [offset (last (last points))]]
              (cond [(= (.upper (get matches :cmd)) "M")
                     (recur (.extend points (lines2beziers (ptlist2matrix (rest pts) (first pts)
                                                                          1 (.isupper cmd))))
                            (first pts) (inc i))]
                    [(= (.upper (get matches :cmd)) "L")
                     (recur (.extend points (lines2beziers (ptlist2matrix pts offset
                                                                          1 (.isupper cmd))))
                            offset (inc 1))]
                    [(= (.upper (get matches :cmd)) "C")
                     (recur
                                              (ptlist2matrix pts offset (int 3) (.isupper cmd)))]
                    [(= (.upper (get matches :cmd)) "Z")
                     (recur (lines2beziers [[offset (first (first points))]]))]
                    [True (raise (Exception "Unknown path command"))])

              )
            points)
          ))



          (let [
           [cmd (.group it (int 1))]
           [nr-str (-> (.group it (int 2)) (.replace  "-" " -") (.replace  "e -" "e-") (.strip))]
           [numbers (map float (remove empty? (split " |," nr-str)))]
           [pts (partition 2 2 numbers)]
           [new-points (cond [(= (.upper cmd) "M")
                              (do (setv offset (first pts))
                                  (lines2beziers (ptlist2matrix (rest pts) offset 1 (.isupper cmd))))]
                             [(= (.upper cmd) "L") (lines2beziers
                                                    (ptlist2matrix pts offset 1 (.isupper cmd)))]
                             [(= (.upper cmd) "H") (lines2beziers
                                                    (ptlist2matrix (zip numbers (repeat (second offset)))
                                                                   offset 1 (.isupper cmd)))]
                             [(= (.upper cmd) "V") (lines2beziers
                                                    (ptlist2matrix (zip (repeat (first offset)) numbers)
                                                                   offset 1 (.isupper cmd)))]
                             [(= (.upper cmd) "C") (do (print "c") (print offset)
                                                       (ptlist2matrix pts offset (int 3) (.isupper cmd)))]
                             [(= (.upper cmd) "S") (add-first-ctrl-pts
                                                    points (ptlist2matrix pts offset 2 (.isupper cmd)))]
                             [(= (.upper cmd) "Q") (elevate-bezier (ptlist2matrix pts offset 2 (.isupper cmd)))]
                             [(= (.upper cmd) "T") (elevate-bezier
                                                    (add-first-ctrl-pts
                                                     points (ptlist2matrix pts offset 1 (.isupper cmd))))]
                             [(= (.upper cmd) "Z") (lines2beziers [[offset (first (first points))]])]
                             [True (raise (Exception "Unknown path command"))])]]
       (unless (empty? new-points)
         (setv offset (last (last new-points)))
         (.extend points new-points)))


                                ;     (catch [e Exception] (print "exception") ;;(warn (.join "" ["Error while interpreting path string part '" (.join "" (.groups it)) "' - this part will be ignored\n" (.args e)]))
                                ;     )

                                (defn reductions [f coll &optional init]
  (print f coll)
  (loop [[res [(if (none? init) (first coll) init)]]
         [acc (if (none? init) (rest coll) coll)]]
        (do (print acc)
         (if (empty? acc)
           (do (.reverse res) res)
           (recur (cons (f (first res) (first acc)) res) (rest acc))))))
(defn reductions [f coll]
  (loop [[res [(first coll)]]
         [acc (rest coll)]]
        (if (empty? acc)
          (do (.reverse res) res)
          (recur (cons (f (first res) (first acc)) res) (rest acc)))))

(defn find-thinnings-old [path]
  (let [;[path (split-segments-to "pathlength" 5.0  path)]
        [ends (map first path)]
        [d (squareform (pdist (array ends)))]
        [neigh-d (max (diagonal  d 1))]
        [c-non-neigh (map (fn [row] (first (list (drop-while
                                                  (fn [y] (not (< 1 (abs (- y (first row)))
                                                                  (- (len row) 1))))
                                                  row))))
                          (argsort d))]
        [pairings (transpose (array [(map first (argsort d)) c-non-neigh]))]
        [pairings2 (list (filter (fn [y] (< 2 (abs (apply sub y)) (- (len (first d)) 2)))
                                 pairings))]
        [pairings3 (set (map (fn [x] (tuple (sort x))) pairings2))]
        [thinnings (map (fn [x] (cross-line [(get ends (first x)) (get ends (second x))]))
                        pairings3)]]
    (array thinnings)))

(defn get-directions-old1 [connected-comp pt-list]
  (map
   (fn [l] (let [[split-list (partition-by (fn [x y] (< 1 (mod-dist n x y))) l)]
                 [n-parts (len split-list)]]
             (cond [(= 2 (len l)) (cross-line [(get pt-list (first l)) (get pt-list (second l))])]
                   [(= 2 (n-parts)) [(average [(get pt-list (first (first l)))
                                               (get pt-list (last (second l)))] 0)
                                     (average [(get pt-list (first (second l)))
                                               (get pt-list (last (first l)))] 0)]])))
   connected-comp))

;
; zu get-directions-old2:
;

(def edges (set [(, 13 33) (, 36 42) (, 1 48)  (, 26 28) (, 17 20) (, 4 45) (, 16 21)
                 (, 24 31) (, 27 29) (, 25 30) (, 38 40) (, 26 29) (, 4 46) (, 9 11)
                 (, 37 41) (, 17 19) (, 8 11)  (, 2 47)  (, 37 40) (, 3 47) (, 13 34)
                 (, 15 21) (, 5 45)  (, 0 48)  (, 16 20) (, 3 46)]))

(def ccs [[0 1 48] [2 3 4 5 45 46 47] [8 9 11] [13 33 34] [15 16 17 19 20 21] [24 31] [25 30] [26 27 28 29] [36 42] [37 38 40 41]])


(defn spit-bipartite-graphs [ccs edges] ;;gg connectedcomp hier implementieren?
  (let [[ems (get-edge-maps edges)]
        [em1 (first ems)]
        [em2 (second ems)]]
    (map (fn [cc]
           (let [[left []]
                 [left-unchecked [(int (first cc))]]
                 [right []]
                 [right-unchecked []]]
             (for [x cc]
               (let [[u-coll (if (empty? left-unchecked) right-unchecked left-unchecked)]
                     [other-u-coll (if (empty? left-unchecked) left-unchecked right-unchecked)]
                     [coll (if (empty? left-unchecked) right left)]
                     [node (.pop u-coll)]]
                 (.append coll node)
                 (for [n (+ (if (in node em2) (get em2 node) [])
                            (if (in node em1) (get em1 node) []))]
                   (unless (or (in n right) (in n left))
                     (.append other-u-coll n)))))
             [left right]))
         ccs)))

(spit-bipartite-graphs ccs edges)

(defn find-thinnings [path]
  (let [[t 4.0]
        [path2 (split-segments-to "pathlength" 5.0  path)]
        [nodes (map first path2)]
        [node-dirs (get-node-dirs path)]

        [n (len ends)]
        [d (squareform (pdist (array nodes)))]

        [inds (- (tile (range n) [n 1])
                 (transpose (tile (range n) [n 1])))]
        [edges (make-set (filter (fn [x] (< 1 (apply sub x) (dec (len ends))))
                                 (transpose (where (< d t)))))]

        [a (print edges "\n")]
        [ind-dists (list (map (fn [x] (mod-dist n (first x) (second x))) edges))]
        [d-edge-map (group-by ind-dists edges)]

        [graph (& (< d t) (< 1 inds) (< inds (- n 1)))]
        [cc (connected_components graph False)]
        [cc2 (list (filter (fn [y] (> (len y) 1))
                           (.values (group-by (second cc) (range 50))))) ]]
        (get-directions cc2 node-dirs edges nodes)
    ))
;; was wenn pfad mittendrin orthogonal abgeht? falluntersch geht schief! wegen falchem split
;; außerdem: nihts garantirt dass stücke gerade sind
(defn get-directions-old2 [connected-comp edges pt-list]
  (map
   (fn [l]
     (cond [(= 2 (len (flatten l))) (cross-line [(get pt-list (first (first l)))
                                                 (get pt-list (first (second l)))])]
           [True [(mean [(get pt-list (first (first l)))
                            (get pt-list (first (second l)))] 0)
                  (mean [(get pt-list (last (second l)))
                            (get pt-list (last (first l)))] 0)]]))
   (spit-bipartite-graphs connected-comp edges)))
